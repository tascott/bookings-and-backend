calculate_available_slots

    -- Validate inputs
    SELECT NULL::TIMESTAMPTZ, NULL::TIMESTAMPTZ, NULL::INT, NULL::BOOLEAN, NULL::INT[], NULL::TEXT
    WHERE in_start_date IS NULL OR in_end_date IS NULL OR in_service_id IS NULL OR in_start_date > in_end_date
    LIMIT 0;

    -- Generate relevant dates within the range
    WITH RelevantDates AS (
        SELECT generate_series(in_start_date, in_end_date, interval '1 day')::date AS potential_date
    ),
    -- Identify potential slots based on service availability rules matching the service and date/day
    PotentialRuleSlots AS (
        SELECT
            r.id AS rule_id,
            r.field_ids,
            r.start_time AS rule_start_time,
            r.end_time AS rule_end_time,
            r.use_staff_vehicle_capacity,
            rd.potential_date,
            (rd.potential_date::timestamp AT TIME ZONE 'UTC' + r.start_time)::timestamptz AS potential_start,
            (rd.potential_date::timestamp AT TIME ZONE 'UTC' + r.end_time)::timestamptz AS potential_end
        FROM RelevantDates rd
        JOIN public.service_availability r ON r.service_id = in_service_id AND r.is_active = true
        WHERE (r.specific_date = rd.potential_date OR (r.specific_date IS NULL AND EXTRACT(ISODOW FROM rd.potential_date) = ANY(r.days_of_week)))
    ),
    -- REMOVED BookedFieldSpots CTE - No longer needed to check field conflicts for staff rules
    -- REMOVED AggregatedFieldAvailability CTE - No longer needed

    -- Determine staff availability and calculate their potential remaining capacity
    StaffCapacity AS (
      SELECT
        prs.potential_start,
        prs.potential_end,
        -- Determine if staff could theoretically be available for this rule/time
        (CASE
           WHEN prs.use_staff_vehicle_capacity = FALSE THEN FALSE -- Rule doesn't use staff
           WHEN in_client_default_staff_id IS NULL THEN FALSE     -- No staff assigned to client
           ELSE EXISTS ( -- Check staff exists, is available, and has vehicle
             SELECT 1
             FROM public.staff s
             LEFT JOIN public.staff_availability sa ON s.id = sa.staff_id -- Use LEFT JOIN in case no specific rule exists but staff is generally available? Needs testing.
             WHERE s.id = in_client_default_staff_id
               AND s.default_vehicle_id IS NOT NULL -- Staff must have a vehicle
               -- Check against the specific rule times/dates
               AND sa.is_available = TRUE
               AND sa.start_time <= prs.rule_start_time AND sa.end_time >= prs.rule_end_time
               AND (sa.specific_date = prs.potential_date OR (sa.specific_date IS NULL AND EXTRACT(ISODOW FROM prs.potential_date) = ANY(sa.days_of_week)))
           )
         END) AS is_staff_available,
        -- Calculate staff's remaining capacity based on their vehicle and overlaps
        CASE
          WHEN prs.use_staff_vehicle_capacity = FALSE THEN NULL -- Not applicable for this rule
          WHEN in_client_default_staff_id IS NULL THEN 0      -- No staff assigned, so 0 capacity
          ELSE (
            WITH StaffAvailCheck AS (
               SELECT 1 FROM public.staff_availability sa WHERE sa.staff_id = in_client_default_staff_id AND sa.is_available = TRUE AND sa.start_time <= prs.rule_start_time AND sa.end_time >= prs.rule_end_time AND (sa.specific_date = prs.potential_date OR (sa.specific_date IS NULL AND EXTRACT(ISODOW FROM prs.potential_date) = ANY(sa.days_of_week))) LIMIT 1
            ), VehicleCapCheck AS (
               SELECT v.pet_capacity FROM public.staff s JOIN public.vehicles v ON s.default_vehicle_id = v.id WHERE s.id = in_client_default_staff_id LIMIT 1
            ), StaffBookedCount AS (
                -- Count pets in overlapping bookings assigned to THIS staff member's USER ID
                SELECT COUNT(bp.id) AS count
                FROM public.bookings b
                JOIN public.booking_pets bp ON b.id = bp.booking_id
                JOIN public.staff st ON st.id = in_client_default_staff_id
                WHERE b.assigned_staff_id = st.user_id -- Join on user_id
                  AND TSTZRANGE(b.start_time, b.end_time, '()') && TSTZRANGE(prs.potential_start, prs.potential_end, '()')
                  AND b.status != 'cancelled'
            )
            SELECT CASE
                     WHEN EXISTS (SELECT 1 FROM StaffAvailCheck) AND EXISTS (SELECT 1 FROM VehicleCapCheck)
                     THEN GREATEST(0, COALESCE((SELECT pet_capacity FROM VehicleCapCheck), 0) - COALESCE((SELECT count FROM StaffBookedCount), 0))
                     ELSE 0 -- Capacity is 0 if staff not available or no vehicle assigned/exists
                   END
          )
        END::INT AS calculated_capacity
      FROM PotentialRuleSlots prs
      WHERE prs.use_staff_vehicle_capacity = TRUE -- Only calculate this for staff rules
    ),
    -- Simplified NonStaffCapacity calculation (if needed for non-staff rules)
    NonStaffCapacity AS (
       SELECT
         prs.potential_start,
         prs.potential_end,
         -- Simplified: Assume unlimited for now unless specific field capacity logic is added later
         NULL::INT AS calculated_capacity
       FROM PotentialRuleSlots prs
       WHERE prs.use_staff_vehicle_capacity = FALSE
    )
    -- Final Aggregation per Time Slot
    SELECT
        prs.potential_start AS slot_start_time,
        prs.potential_end AS slot_end_time,
        -- Determine final remaining capacity
        CASE
            -- Directly use calculated staff capacity if rule uses staff
            WHEN prs.use_staff_vehicle_capacity = TRUE THEN COALESCE(sc.calculated_capacity, 0)
            -- Use non-staff capacity otherwise (currently NULL = unlimited)
            ELSE nsc.calculated_capacity
        END AS slot_remaining_capacity,
        prs.use_staff_vehicle_capacity AS rule_uses_staff_capacity,
        prs.field_ids AS associated_field_ids,
        -- Calculate zero_capacity_reason
        CASE
            -- If capacity > 0 or unlimited (NULL), reason is null
            WHEN (
                 CASE
                    WHEN prs.use_staff_vehicle_capacity = TRUE THEN COALESCE(sc.calculated_capacity, 0)
                    ELSE 999999 -- Represent unlimited (NULL) as large number for comparison
                 END
            ) > 0 THEN NULL
            -- If capacity is determined to be 0 for staff rule
            WHEN prs.use_staff_vehicle_capacity = TRUE THEN
                CASE
                    -- Check if staff *could* have been available but capacity is 0 (vehicle full)
                    WHEN sc.is_staff_available = TRUE THEN 'staff_full'::text
                    -- Otherwise, capacity is 0 because staff weren't available/assigned/had vehicle
                    ELSE 'no_staff'::text
                END
            -- Add logic here if non-staff capacity can become 0 later
            ELSE NULL::text -- Default for non-staff rules if capacity isn't 0
        END AS zero_capacity_reason
    FROM
        PotentialRuleSlots prs
    LEFT JOIN
        StaffCapacity sc ON prs.potential_start = sc.potential_start AND prs.potential_end = sc.potential_end AND prs.use_staff_vehicle_capacity = TRUE
    LEFT JOIN
        NonStaffCapacity nsc ON prs.potential_start = nsc.potential_start AND prs.potential_end = nsc.potential_end AND prs.use_staff_vehicle_capacity = FALSE;


////////////////////////////////////////

check_array_elements_range

DECLARE
  el INTEGER;
BEGIN
  IF arr IS NULL THEN
    RETURN TRUE; -- Null arrays satisfy the check
  END IF;
  IF array_length(arr, 1) = 0 THEN
    RETURN TRUE; -- Empty arrays satisfy the check
  END IF;
  FOREACH el IN ARRAY arr LOOP
    IF el < min_val OR el > max_val THEN
      RETURN FALSE; -- Element out of range
    END IF;
  END LOOP;
  RETURN TRUE; -- All elements are within range
END;

/////////////////////////////////////////


handle_new_user

BEGIN
  -- Insert into profiles table using metadata passed during signup
  INSERT INTO public.profiles (user_id, first_name, last_name, phone)
  VALUES (
    NEW.id,
    NEW.raw_user_meta_data ->> 'first_name',
    NEW.raw_user_meta_data ->> 'last_name',
    NEW.raw_user_meta_data ->> 'phone'
  );

  -- Optionally, insert into clients with just user_id and email
  INSERT INTO public.clients (user_id, email)
  VALUES (NEW.id, NEW.email);

  RETURN NEW;
END;



update_staff_availability_updated_at


BEGIN
   NEW.updated_at = NOW();
   RETURN NEW;
END;
