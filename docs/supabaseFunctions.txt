calculate_available_slots


    -- Validate inputs
    SELECT NULL::TIMESTAMPTZ, NULL::TIMESTAMPTZ, NULL::INT, NULL::BOOLEAN, NULL::INT[], NULL::TEXT
    WHERE in_start_date IS NULL OR in_end_date IS NULL OR in_service_id IS NULL OR in_start_date > in_end_date
    LIMIT 0;

    -- Generate relevant dates within the range
    WITH RelevantDates AS (
        SELECT generate_series(in_start_date, in_end_date, interval '1 day')::date AS potential_date
    ),
    -- Identify potential slots based on service availability rules matching the service and date/day
    PotentialRuleSlots AS (
        SELECT
            r.id AS rule_id,
            r.field_ids,
            r.start_time AS rule_start_time,
            r.end_time AS rule_end_time,
            r.use_staff_vehicle_capacity,
            rd.potential_date,
            (rd.potential_date::timestamp AT TIME ZONE 'UTC' + r.start_time)::timestamptz AS potential_start,
            (rd.potential_date::timestamp AT TIME ZONE 'UTC' + r.end_time)::timestamptz AS potential_end
        FROM RelevantDates rd
        JOIN public.service_availability r ON r.service_id = in_service_id AND r.is_active = true
        WHERE (r.specific_date = rd.potential_date OR (r.specific_date IS NULL AND EXTRACT(ISODOW FROM rd.potential_date) = ANY(r.days_of_week)))
    ),
    -- Calculate booked pet count per field for the potential slot times
    -- Used only to check if *all* fields are occupied when staff capacity is used.
    BookedFieldSpots AS (
        SELECT
           prs.potential_start,
           prs.potential_end,
           f.id as field_id,
           COUNT(bp.id) AS booked_pet_spots
       FROM PotentialRuleSlots prs
       JOIN public.fields f ON f.id = ANY(prs.field_ids)
       -- Use booking_field_ids for join now
       LEFT JOIN public.bookings b ON f.id = ANY(b.booking_field_ids)
                          AND TSTZRANGE(b.start_time, b.end_time, '()') && TSTZRANGE(prs.potential_start, prs.potential_end, '()')
                          AND b.status != 'cancelled'
       LEFT JOIN public.booking_pets bp ON b.id = bp.booking_id
       WHERE prs.use_staff_vehicle_capacity = TRUE -- Only needed for staff rules to check if all fields are blocked
       GROUP BY prs.potential_start, prs.potential_end, f.id
    ),
    -- Check if all relevant fields for a rule slot are booked
    -- This helps determine if a slot is unavailable even if staff *could* take it, because all physical spaces are full.
    AggregatedFieldAvailability AS (
        SELECT
            prs.potential_start,
            prs.potential_end,
            COUNT(bfs.field_id) FILTER (WHERE bfs.booked_pet_spots > 0) AS booked_field_count,
            ARRAY_LENGTH(prs.field_ids, 1) AS total_field_count
        FROM PotentialRuleSlots prs
        LEFT JOIN BookedFieldSpots bfs ON prs.potential_start = bfs.potential_start
                                       AND prs.potential_end = bfs.potential_end
                                       AND bfs.field_id = ANY(prs.field_ids)
        WHERE prs.use_staff_vehicle_capacity = TRUE
        GROUP BY prs.potential_start, prs.potential_end, prs.field_ids
    ),
    -- Determine staff availability and calculate their potential remaining capacity
    StaffCapacity AS (
      SELECT
        prs.potential_start,
        prs.potential_end,
        -- Determine if staff could theoretically be available for this rule/time
        (CASE
           WHEN prs.use_staff_vehicle_capacity = FALSE THEN FALSE -- Rule doesn't use staff
           WHEN in_client_default_staff_id IS NULL THEN FALSE     -- No staff assigned to client
           ELSE EXISTS ( -- Check staff exists, is available, and has vehicle
             SELECT 1
             FROM public.staff s
             JOIN public.staff_availability sa ON s.id = sa.staff_id
             WHERE s.id = in_client_default_staff_id
               AND s.default_vehicle_id IS NOT NULL -- Staff must have a vehicle
               AND sa.is_available = TRUE
               AND sa.start_time <= prs.rule_start_time AND sa.end_time >= prs.rule_end_time
               AND (sa.specific_date = prs.potential_date OR (sa.specific_date IS NULL AND EXTRACT(ISODOW FROM prs.potential_date) = ANY(sa.days_of_week)))
           )
         END) AS is_staff_available,
        -- Calculate staff's remaining capacity based on their vehicle and overlaps
        CASE
          WHEN prs.use_staff_vehicle_capacity = FALSE THEN NULL -- Not applicable for this rule
          WHEN in_client_default_staff_id IS NULL THEN 0      -- No staff assigned, so 0 capacity
          ELSE (
            WITH StaffAvailCheck AS (
               SELECT 1 FROM public.staff_availability sa WHERE sa.staff_id = in_client_default_staff_id AND sa.is_available = TRUE AND sa.start_time <= prs.rule_start_time AND sa.end_time >= prs.rule_end_time AND (sa.specific_date = prs.potential_date OR (sa.specific_date IS NULL AND EXTRACT(ISODOW FROM prs.potential_date) = ANY(sa.days_of_week))) LIMIT 1
            ), VehicleCapCheck AS (
               SELECT v.pet_capacity FROM public.staff s JOIN public.vehicles v ON s.default_vehicle_id = v.id WHERE s.id = in_client_default_staff_id LIMIT 1
            ), StaffBookedCount AS (
                -- Count pets in overlapping bookings assigned to THIS staff member's USER ID
                SELECT COUNT(bp.id) AS count
                FROM public.bookings b
                JOIN public.booking_pets bp ON b.id = bp.booking_id
                JOIN public.staff st ON st.id = in_client_default_staff_id
                WHERE b.assigned_staff_id = st.user_id -- Join on user_id
                  AND TSTZRANGE(b.start_time, b.end_time, '()') && TSTZRANGE(prs.potential_start, prs.potential_end, '()')
                  AND b.status != 'cancelled'
            )
            SELECT CASE
                     WHEN EXISTS (SELECT 1 FROM StaffAvailCheck) AND EXISTS (SELECT 1 FROM VehicleCapCheck)
                     THEN GREATEST(0, COALESCE((SELECT pet_capacity FROM VehicleCapCheck), 0) - COALESCE((SELECT count FROM StaffBookedCount), 0))
                     ELSE 0 -- Capacity is 0 if staff not available or no vehicle assigned/exists
                   END
          )
        END::INT AS calculated_capacity
      FROM PotentialRuleSlots prs
    )
    -- Removed TotalBookedFieldCapacity CTE

    -- Final Aggregation per Time Slot
    SELECT
        prs.potential_start AS slot_start_time,
        prs.potential_end AS slot_end_time,
        -- Determine final remaining capacity
        CASE
            WHEN prs.use_staff_vehicle_capacity = TRUE THEN
                CASE
                    -- If all associated fields are fully booked (e.g., by other services/staff), capacity is 0 regardless of *this* staff's capacity
                    WHEN COALESCE(afa.booked_field_count, 0) = COALESCE(afa.total_field_count, 0) AND COALESCE(afa.total_field_count, 0) > 0 THEN 0
                    -- Otherwise, use the calculated capacity for the specific staff member
                    ELSE COALESCE(sc.calculated_capacity, 0)
                END
            ELSE -- Rule does not use staff vehicle capacity, treat as unlimited from rule perspective
                NULL::INT
        END AS slot_remaining_capacity,
        prs.use_staff_vehicle_capacity AS rule_uses_staff_capacity,
        prs.field_ids AS associated_field_ids,
        -- Calculate zero_capacity_reason
        CASE
            -- If capacity > 0 or unlimited (NULL), reason is null
            WHEN (
                 CASE
                    WHEN prs.use_staff_vehicle_capacity = TRUE THEN
                        CASE WHEN COALESCE(afa.booked_field_count, 0) = COALESCE(afa.total_field_count, 0) AND COALESCE(afa.total_field_count, 0) > 0 THEN 0 ELSE COALESCE(sc.calculated_capacity, 0) END
                    ELSE 999999 -- Represent unlimited (NULL) as large number for comparison
                 END
            ) > 0 THEN NULL
            -- If capacity is determined to be 0
            ELSE
                CASE
                    WHEN prs.use_staff_vehicle_capacity = TRUE THEN
                        CASE
                            -- Check if staff *could* have been available (from StaffCapacity CTE) but capacity is now 0 (vehicle full or fields blocked)
                            WHEN sc.is_staff_available = TRUE THEN 'staff_full'::text -- Includes fields blocked case now
                            -- Otherwise, capacity is 0 because staff weren't available/assigned/had vehicle
                            ELSE 'no_staff'::text
                        END
                    -- Base capacity rules no longer exist, so 'base_full' reason is removed.
                    -- If non-staff capacity becomes 0 due to future constraints, add a reason here.
                    ELSE NULL::text -- Should not be 0 if use_staff_vehicle_capacity is false based on current logic
                END
        END AS zero_capacity_reason
    FROM
        PotentialRuleSlots prs
    LEFT JOIN
        StaffCapacity sc ON prs.potential_start = sc.potential_start
                         AND prs.potential_end = sc.potential_end
    LEFT JOIN
        AggregatedFieldAvailability afa ON prs.potential_start = afa.potential_start
                                       AND prs.potential_end = afa.potential_end
                                       AND prs.use_staff_vehicle_capacity = TRUE; -- Only join this for staff rules


////////////////////////////////////////

check_array_elements_range

DECLARE
  el INTEGER;
BEGIN
  IF arr IS NULL THEN
    RETURN TRUE; -- Null arrays satisfy the check
  END IF;
  IF array_length(arr, 1) = 0 THEN
    RETURN TRUE; -- Empty arrays satisfy the check
  END IF;
  FOREACH el IN ARRAY arr LOOP
    IF el < min_val OR el > max_val THEN
      RETURN FALSE; -- Element out of range
    END IF;
  END LOOP;
  RETURN TRUE; -- All elements are within range
END;

/////////////////////////////////////////


handle_new_user

BEGIN
  -- Insert into profiles table using metadata passed during signup
  INSERT INTO public.profiles (user_id, first_name, last_name, phone)
  VALUES (
    NEW.id,
    NEW.raw_user_meta_data ->> 'first_name',
    NEW.raw_user_meta_data ->> 'last_name',
    NEW.raw_user_meta_data ->> 'phone'
  );

  -- Optionally, insert into clients with just user_id and email
  INSERT INTO public.clients (user_id, email)
  VALUES (NEW.id, NEW.email);

  RETURN NEW;
END;



update_staff_availability_updated_at


BEGIN
   NEW.updated_at = NOW();
   RETURN NEW;
END;
